<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Fall2016-project-cesiu by cpe305</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Fall2016-project-cesiu</h1>
          <h2>fall2016-project-cesiu created by GitHub Classroom</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/cpe305/fall2016-project-cesiu/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/cpe305/fall2016-project-cesiu/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/cpe305/fall2016-project-cesiu" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <p><a href="https://travis-ci.org/cpe305/fall2016-project-cesiu"><img src="https://travis-ci.org/cpe305/fall2016-project-cesiu.svg?branch=master" alt="Build Status"></a></p>

<p><img src="https://github.com/cpe305/fall2016-project-cesiu/blob/master/diagrams/GameScreen.png?raw=true" alt="ui mock"></p>

<p>SmartRochambeau is a single player Rock-Paper-Scissors game featuring four
different AI opponents, developed as an individual project for Professor
Gudrun Socher's CPE 305 at Cal Poly, Fall 2016.</p>

<h2>
<a id="installing" class="anchor" href="#installing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installing</h2>

<p>Only the cross-platform SmartRochambeau.jar is required to run the game.</p>

<h2>
<a id="running" class="anchor" href="#running" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Running</h2>

<p>SmartRochambeau can be run by double clicking on the JAR or from the command 
line using <code>java -jar SmartRochambeau.jar</code>.</p>

<p>SmartRochambeau keeps track of win-loss-tie statistics and supports saved games.</p>

<h2>
<a id="opponents" class="anchor" href="#opponents" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Opponents</h2>

<p>SmartRochambeau features four AI opponents:</p>

<ul>
<li>A random AI as a control, which simply selects a random throw every round.</li>
<li>A Markov Chain AI modeled using nine states and three intermediate states, 
which answers the question, "Considering what the player threw last and 
whether or not he won, what is he likely to throw next?". At any given time, 
the current state is determined by the player's last throw and the result of 
that round, e.g., "Rock, win". Each state contains frequencies logging how 
often, when the game is at that current state, the player has moved according 
to each of the three intermediate states, which contain only a throw, e.g., 
"Paper". For example, the state "Rock, win" would contain three numbers 
corresponding to how often, after playing Rock and winning, the player then 
threw Rock, Paper, and Scissors. Based on those numbers, the AI can predict 
the player's most likely next move. The AI trains as it runs, updating the 
frequencies once it knows the outcome of the current round before it moves to
the next state.</li>
<li>A Naive Bayes AI -- implemented mostly as an experiment, not because I thought
it was necessarily a good algorithm for this problem -- that attempts to
answer the question, "Considering the player's last few throws, what is he
leading up to throwing?". The idea being, a Markov-Chain-based is vulnerable
because Rock-Paper-Scissors doesn't really satisfy the Markov Property; what
the player does next is not solely dependant on what he did last. The Naive
Bayes AI attempts to defeat 'longer' strategies wherein the player makes a
few moves to set his opponent up for a later move. The AI maintains a queue
of the player's last few throws as well as nine frequencies for how often each
individual throw 'led up to' each of the other throws. For example, if the
last three throws were "Rock, Paper, Rock", the AI can look at how often,
historically, Rock and Paper have indivdually led up to Rock, Paper, or
Scissors, then combine those probabilities using Bayes Rule. Like the Markov
Chain AI, the Naive Bayes AI is capable of training as it goes, though this
makes it vulnerable to overfitting and thus long term shifts in strategy.</li>
<li>A Pattern Matching AI, which I personally predicted would do best of the 
three, that attempts to answer the same question as the Naive Bayes AI, but
based on the pattern of the individual throws, not their general overall
frequencies. The AI maintains a complete ternary tree of throws to allow
for faster pattern matching, with each possible pattern represented as a
unique path from root to a leaf, and each leaf, as you might expect, contains
frequencies for each of the three throws. The Pattern Matching AI, too, is
capable of training as it runs..</li>
</ul>

<p>These AI all share a common drawback: training as they go makes them easy to
set up and play immediately, but it makes them vulnerable to overfitting. A
player might make a slight change to his strategy, and the AI might take
a long time to catch up.</p>

<p>One possible solution is to count how many times the AI has used a throw for 
training. After a certain threshold, whether that be related to number of throws
trained on, win rate, or some combination thereof, the AI stops saving
information after each round. After a certain amount of time or after the win
rate drops below some other threshold, the AI can start training again, perhaps
partially or completely "wiping the slate" and deleting some or all of its saved
information.</p>

<h2>
<a id="architecture" class="anchor" href="#architecture" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Architecture</h2>

<p><img src="https://github.com/cpe305/fall2016-project-cesiu/blob/master/diagrams/classDiagram.png?raw=true" alt="class diagram"></p>

<p>SmartRochambeau uses a modified Model-View-Controller architecture pattern, with
a controller class providing a generalized interface to the UI for the core
logic and also giving the UI access to methods of the core logic. Both the UI
and the AI implement interfaces designed to make adding new machine learning AI
easy. </p>
        </section>

        <footer>
          Fall2016-project-cesiu is maintained by <a href="https://github.com/cpe305">cpe305</a><br>
          This page was generated by <a href="https://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>
